# No K-th

Имате дадено двоично дърво (BST) за търсене с N елемента и цяло число K. Изтрийте K-тия най-голям елемент и изведете стойностите на дървото подредени по нива от дясно на ляво (level order). Ако изтритият елемент има два наследника, елементът заемащ мястото на изтрития е най-лявото листо в дясното му поддърво.

Иска се да изведете първо корена после върховете на ниво 1 от ляво на дясно и после върховете от ниво 2 от ляво на дясно и тн.

### Input Format

На първия ред от стандартният вход се въвеждат N и K.

Следват N на брой цели числа a0, .., aN-1 - елементите, които трябва да се добавят в дървото. Родителят на елементa ai е a(i-1)/2.

Върхът, който съдържа стойността на индекс i в масива е родител на върховете със стойности съответно на индекси 2*i + 1 и 2*i + 2.

### Constraints

1 <= N <= 10^5 <br>
0 <= ai <= 10^5

### Output format

Изведете N-1 цели числа - останалите елементи в дървото, след премахването на K-тия най-голям.

### Sample Input 0

5 1 <br>
4 2 7 1 3

### Sample Output 0

4 2 1 3

### Explanation 0

<pre>
     4
    /
   2 
  / \
 1   3
</pre>

1-вият най-голям елемент е 7 => след изтриването му дървото изглежда така:

<pre>
     4
    / \
   2   7
  / \
 1   3
</pre>

### Sample Input 1

6 5 <br>
10 8 12 7 9 11

### Sample Output 1

10 9 12 7 11

### Explanation 1

<pre>
     10
    /  \
   8    12
  / \   /
 7   9 11
</pre>

5-тият най-голям елемент е 8 => след изтриването му дървото изглежда така:

<pre>
     10
    /  \
   9    12
  /     /
 7     11
</pre>
